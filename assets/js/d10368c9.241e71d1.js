"use strict";(globalThis.webpackChunkhumanoid_book=globalThis.webpackChunkhumanoid_book||[]).push([[4147],{4687:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"chapter11","title":"Chapter 11: Sim-to-Real Transfer Techniques","description":"Developing and training robot behaviors in simulation is often faster, safer, and more scalable than working with physical hardware. However, the ultimate goal is to deploy these behaviors on real robots. This chapter explores \\"sim-to-real\\" transfer\u2014the art and science of bridging the gap between simulation and reality.","source":"@site/book/chapter11.md","sourceDirName":".","slug":"/chapter11","permalink":"/AI-humanoid-book/book/chapter11","draft":false,"unlisted":false,"editUrl":"https://github.com/Umerqureshi786/AI-humanoid-book/tree/main/book/chapter11.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"title":"Chapter 11: Sim-to-Real Transfer Techniques","sidebar_position":11},"sidebar":"defaultSidebar","previous":{"title":"Chapter 10: Vision-Language-Action Models","permalink":"/AI-humanoid-book/book/chapter10"},"next":{"title":"Chapter 12: Current Humanoid Platforms Comparison","permalink":"/AI-humanoid-book/book/chapter12"}}');var a=i(4848),o=i(8453);const r={title:"Chapter 11: Sim-to-Real Transfer Techniques",sidebar_position:11},s="Chapter 11: Sim-to-Real Transfer Techniques",l={},c=[{value:"Domain Randomization",id:"domain-randomization",level:2},{value:"System Identification",id:"system-identification",level:2},{value:"Fine-tuning in the Real World",id:"fine-tuning-in-the-real-world",level:2}];function h(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chapter-11-sim-to-real-transfer-techniques",children:"Chapter 11: Sim-to-Real Transfer Techniques"})}),"\n",(0,a.jsx)(n.p,{children:'Developing and training robot behaviors in simulation is often faster, safer, and more scalable than working with physical hardware. However, the ultimate goal is to deploy these behaviors on real robots. This chapter explores "sim-to-real" transfer\u2014the art and science of bridging the gap between simulation and reality.'}),"\n",(0,a.jsx)(n.h2,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,a.jsx)(n.p,{children:"One of the most effective techniques for improving sim-to-real transfer is domain randomization. The core idea is to expose the learning algorithm to a wide variety of simulation conditions, forcing it to learn a robust policy that is less sensitive to the specific parameters of any single environment. We will cover:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Visual Randomization"}),": Varying textures, lighting conditions, and camera properties."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dynamics Randomization"}),": Perturbing physical parameters like mass, friction, and actuator delays."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"system-identification",children:"System Identification"}),"\n",(0,a.jsx)(n.p,{children:"System identification aims to build an accurate mathematical model of a real-world system from experimental data. For robotics, this involves:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Estimating Physical Parameters"}),": Measuring joint friction, link masses, and motor characteristics."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Learning Dynamics Models"}),": Using machine learning to create a model that accurately predicts the robot's behavior.\r\nAn accurate model of the real robot can be used to create a more realistic simulation, thus reducing the sim-to-real gap."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"fine-tuning-in-the-real-world",children:"Fine-tuning in the Real World"}),"\n",(0,a.jsx)(n.p,{children:"Even with advanced simulation and modeling, some amount of fine-tuning on the physical robot is often necessary. This section will discuss:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reinforcement Learning on Hardware"}),": Safely and efficiently running RL algorithms on the physical robot."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Bayesian Optimization"}),": A sample-efficient method for tuning control policy parameters."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Imitation Learning"}),": Using human demonstrations to bootstrap learning in the real world."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var t=i(6540);const a={},o=t.createContext(a);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);